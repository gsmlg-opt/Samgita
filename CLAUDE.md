# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Samgita is an Elixir/OTP reimplementation of [loki-mode](https://github.com/asklokesh/loki-mode), designed for distributed multi-agent orchestration. The goal is to transform Product Requirements Documents into fully deployed software products through coordinated AI agent swarms running on the BEAM VM.

**Status**: Greenfield project - implementation has not started. Currently only documentation exists (README.md, PRD.md, PLAN.md).

**Source Reference**: The original loki-mode implementation is available at `./loki-mode/` for architecture reference.

## Architecture Foundation

### Core Design Principles (from PLAN.md ADRs)

**ADR-001: Process Architecture**
- Use `gen_statem` for Orchestrator and Agent workers (not GenServer)
- RARV cycle (Reason-Act-Reflect-Verify) maps to state machine states
- State transitions must be explicit and auditable

**ADR-002: Distribution Strategy**
- Horde + Oban + Postgres (not Mnesia)
- Postgres is single source of truth to eliminate split-brain scenarios
- Oban handles distributed task queue
- Horde CRDTs handle process registry/supervisor distribution

**ADR-003: Persistence Layers**
- Hybrid ETS (hot/runtime) + Ecto (cold/persistent)
- Agent state lives in process state with Postgres snapshots
- Task queue is Oban-backed
- Memory/context uses ETS with Postgres + pgvector for persistence

**ADR-004: Claude Integration**
- Use Claude CLI via Erlang Port (NOT direct API)
- Reuses host's existing authentication
- Simpler deployment with no API key management

### Supervision Tree Structure

```
Samgita.Application
├── Samgita.Repo
├── Phoenix.PubSub (pg adapter for clustering)
├── Horde.Registry (Samgita.AgentRegistry)
├── Horde.DynamicSupervisor (Samgita.ProjectSupervisor)
│   └── per project:
│       Samgita.Project.Supervisor
│       ├── Orchestrator (gen_statem) - phase management
│       ├── Memory (GenServer) - context/learnings
│       └── Agent workers (gen_statem) - RARV cycle
├── Oban (distributed job queue)
└── SamgitaWeb.Endpoint
```

### RARV Cycle State Machine

Each agent executes as a `gen_statem` with these states:

```
:idle -> :reason -> :act -> :reflect -> :verify
          ^                              |
          └─────────on failure───────────┘
```

- **:reason** - Load continuity log, identify approach
- **:act** - Execute via Claude CLI, commit checkpoint
- **:reflect** - Update memory, record learnings
- **:verify** - Run tests, validate output, retry on failure

### Data Model (Ecto Schemas)

**Core Entities:**
- `Project` - git_url (canonical ID), working_path, prd_content, phase, status
- `Task` - priority, status, payload, agent assignments
- `AgentRun` - agent_type, node, pid, status, metrics
- `Artifact` - code, docs, configs generated by agents
- `Memory` - episodic/semantic/procedural memory with pgvector
- `Snapshot` - periodic state checkpoints for recovery

**Key Pattern**: `git_url` is the canonical project identifier, surviving path changes and machine migrations.

## Implementation Phases (from PLAN.md)

### Phase 1: Foundation (Week 1-2)
- Phoenix scaffold with LiveView
- Ecto schemas and migrations
- Basic REST API for projects
- Agent worker gen_statem skeleton

### Phase 2: Core Engine (Week 3-4)
- Orchestrator state machine (phase transitions)
- Task queue with Oban
- RARV cycle implementation
- Claude CLI integration (Port-based)

### Phase 3: Distribution (Week 5-6)
- Horde integration
- Cross-node agent migration
- Distributed PubSub
- Snapshot/recovery system

### Phase 4: Web Dashboard (Week 7-8)
- LiveView dashboard with real-time updates
- Agent monitor, task kanban, log streaming
- PRD editor with file upload
- Git URL-based project creation with auto-detection

### Phase 5: Production Ready (Week 9-10)
- API authentication
- Webhook system
- Telemetry/metrics
- Documentation

## Development Commands

**Note**: No Elixir code exists yet. Once Phoenix is scaffolded, standard commands will be:

```bash
# Setup
mix deps.get
mix ecto.setup

# Development
mix phx.server         # Start server (default port: 3110)
iex -S mix phx.server  # Start with IEx

# Testing
mix test
mix test path/to/test.exs:line  # Run single test

# Code quality
mix format             # Format code
mix credo --strict     # Linting
mix dialyzer          # Type checking

# Database
mix ecto.gen.migration name
mix ecto.migrate
mix ecto.rollback

# Multi-node clustering
iex --sname node1 --cookie samgita -S mix phx.server
iex --sname node2 --cookie samgita -S mix phx.server
```

## Agent Types (37 from loki-mode)

### Engineering Swarm (8)
eng-frontend, eng-backend, eng-database, eng-mobile, eng-api, eng-qa, eng-perf, eng-infra

### Operations Swarm (8)
ops-devops, ops-sre, ops-security, ops-monitor, ops-incident, ops-release, ops-cost, ops-compliance

### Business Swarm (8)
biz-marketing, biz-sales, biz-finance, biz-legal, biz-support, biz-hr, biz-investor, biz-partnerships

### Data Swarm (3)
data-ml, data-eng, data-analytics

### Product Swarm (3)
prod-pm, prod-design, prod-techwriter

### Growth Swarm (4)
growth-hacker, growth-community, growth-success, growth-lifecycle

### Review Swarm (3)
review-code, review-business, review-security

See `loki-mode/references/agent-types.md` for detailed agent definitions.

## Key Patterns from loki-mode

### Progressive Disclosure Architecture
- Keep core skill files minimal (SKILL.md ~190 lines in loki-mode)
- Load detailed documentation on-demand
- Use skills/00-index.md routing pattern for module selection

### Quality Gates (7-gate system)
1. Static analysis (CodeQL, ESLint)
2. 3-reviewer parallel system (blind review)
3. Anti-sycophancy checks (devil's advocate on unanimous approval)
4. Severity-based blocking (Critical/High/Medium = BLOCK)
5. Test coverage gates (>80% unit, 100% pass)
6. Security audit
7. Load testing

### Memory System
- **Episodic**: Specific interaction traces
- **Semantic**: Generalized patterns
- **Procedural**: Learned skills

### Model Selection Strategy (from loki-mode)
- **Opus**: Planning and architecture ONLY
- **Sonnet**: Development and functional testing
- **Haiku**: Unit tests, monitoring, simple tasks - use extensively for parallelization

## Git Workflow

### Project Identity
- `git_url` is the canonical identifier (e.g., git@github.com:org/repo.git)
- `working_path` is auto-detected or manually set
- Auto-detect local clones by checking common paths
- Clone automatically if git URL provided but not found locally

### Cross-Machine Migration
- Projects can be imported on new machines using the same git_url
- State syncs via git, continues from last phase
- Snapshots stored in Postgres, not tied to local filesystem

## Critical Constraints

### Never Use
- Direct Anthropic API - use Claude CLI via Port instead
- GenServer for RARV cycle - use gen_statem
- Mnesia - use Postgres
- File-based state - use Postgres + Oban + ETS

### Always Use
- Postgres as single source of truth
- Oban for distributed task queue
- Horde for process distribution
- gen_statem for state machines
- Phoenix.PubSub for real-time updates
- LiveView for dashboard (not polling)

## Frontend & UI Conventions

### UI Component Library
- **Always use UI components from the `@duskmoon-dev` npm group**
- Prefer `@duskmoon-dev` packages for frontend UI elements (markdown rendering, custom elements, etc.)
- Example: `@duskmoon-dev/el-markdown` for markdown rendering

### Custom Elements
- Use web components (Custom Elements) for reusable UI functionality
- Register custom elements with semantic naming (e.g., `<el-dm-markdown>`)
- Import and initialize custom elements in `assets/js/app.ts`

### Styling
- Use Tailwind CSS for all styling
- Follow Tailwind Typography (`prose` classes) for content formatting
- Maintain consistent color schemes across components

## Claude Integration Modules

Samgita provides two ways to interact with Claude:

### ClaudeAgent (lib/claude_agent.ex)
- **Wrapper for Claude Code CLI** - spawns CLI as subprocess
- **Authentication**: Uses Claude Code's built-in auth (OAuth or API key)
- **Tools**: All Claude Code tools available automatically
- **Use case**: Rapid prototyping, development, quick testing
- **Matches**: `@anthropic-ai/claude-agent-sdk` architecture
- **Aligns with**: ADR-004 (Use Claude CLI via Erlang Port)

### ClaudeAPI (lib/claude_api.ex)
- **Direct HTTP API calls** - uses Anthropic Messages API
- **Authentication**: Manual ANTHROPIC_API_KEY or CLAUDE_CODE_OAUTH_TOKEN
- **Tools**: Custom tool implementations (Read, Write, Edit, Bash, etc.)
- **Use case**: Production systems, fine-grained control, minimal dependencies
- **Matches**: Direct API integration pattern

**When to use ClaudeAgent:**
- Prototyping and development
- Need all Claude Code tools immediately
- Already using Claude Code CLI
- Want CLI-managed authentication

**When to use ClaudeAPI:**
- Production systems
- Fine-grained control over API calls
- Minimize external dependencies
- Custom tool implementations

## Research Foundation

Samgita inherits patterns from loki-mode's research foundation:

**OpenAI**: Agents SDK (guardrails, tripwires, handoffs)
**DeepMind**: Constitutional AI, Scalable Oversight via Debate, SIMA 2
**Anthropic**: Claude Code Best Practices, Alignment Faking Detection
**Academic**: CONSENSAGENT (anti-sycophancy), GoalAct (hierarchical planning), ToolOrchestra (efficiency metrics)

See `loki-mode/references/openai-patterns.md`, `loki-mode/references/lab-research-patterns.md`, and `loki-mode/references/advanced-patterns.md` for detailed patterns.

## Performance Targets (from PRD.md)

| Metric | Target |
|--------|--------|
| Dashboard update latency | <100ms |
| Task dispatch latency | <10ms |
| Agent spawn time | <50ms |
| API response (p95) | <200ms |
| Concurrent agents per node | 1,000+ |
| Concurrent projects | 100+ |
| Uptime | 99.9% |
| Recovery (single node) | <30s |

## Important References

- **PRD.md** - Complete product requirements, data models, API spec
- **PLAN.md** - 5-phase implementation plan with file checklist
- **README.md** - High-level architecture and tech stack
- **loki-mode/CLAUDE.md** - Original implementation guidance
- **loki-mode/SKILL.md** - Core skill architecture (~190 lines)
- **loki-mode/references/** - 19 detailed reference docs
